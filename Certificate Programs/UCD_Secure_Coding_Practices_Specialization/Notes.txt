Robust Programming

	- Requires that ALL possible inputs are accounted for
	- Requires that ALL possible outcomes are handled (including a generic error handler)
	
	- Shims
		- Act as a guard/checker for the inputs of a secure system when receiving input from a system whose security is unknown
		- I think of it as a filtration process that makes sure only pristine/expected input can enter the secure system
	
	- Common Issues
		- Assume the environment is trustworthy
			- What happens if my trust is misplaced?
		- Do not prepare for worst case scenario; only handle typical inputs 
			- e.g., expect int as input, but can't handle if person inputs string
	
	- General Philosophy
		- Always check assumptions
			- What happens if my assumption is wrong?
		- Encourage lateral thinking
			- e.g., Netherlands high school student breaking into high security place in the U.S.; asked his mother to stop him
		
8 Design Principles for Secure Programming

	1.) Least Privilege
		- Principle of least privilege (PoLP)
			- Requires that a process only have as much privilege as is needed to complete its task and no more
				- You can add privileges as needed, but need to remove them when they are no longer necessary
				- Thus fuction controls the rights, not the identity
					- As a result, getting 'root' would only enable the user to accomplish the stated task and not some unrelated task
		- Principle of least authority (PoLA)
			- Different from PoLP in that PoLP deals with direct actions on an object and PoLA deals with indirect actions
				- "What can I do to the object?" as opposed to "What can I do with the object?"
				
	2.) Fail-safe Defaults
		- Default is to deny access
		- Upon failure of a process, make sure the system maintains/returns to a secure state
		- Futureproof checks
			- e.g., instead of checking for membership on a blacklist, use a whitelist instead
		
	3.) Economy of Mechanism
		- KISS
		- The fewer moving parts a system has, the fewer opportunities exist for failure in any of the given parts
		
	4.) Complete Mediation
		- Check/authorize all accesses
			- e.g., Check for write access upon each attempt to write to a file instead of only checking once when the file is first opened
		
	5.) Open Design
		- No "security through obscurity"
			- If an adversary can discover the design of your implementation, you are still NOT vulnerable to attack
	
	6.) Separation of Privilege
		- Think of a castle: to get to the king, you must first -
			- Cross the moat
			- Pass through the portcullis
			- Enter the keep
			- Enter the throneroom
		- Think of multisig wallets: in order to complete a transaction, multiple wallets must approve it
		- Must satisfy multiple conditions in order to access a given resource
			
	7.) Least Common Mechanism
		- Share nothing beyond what is essential
		- Isolate processes as much as possible
			- e.g., VMs, sandboxes
		
	8.) Least Astonishment
		- Make security easy--both why it's necessary, and its use.
		- Security measures will make access more difficult, but it should not unnecessarily increase the difficulty
			- e.g., requiring a blood sample, urine sample, and sperm sample just to sign into your email account; a password is sufficient (2FA is better)
	
	- What do these share in common
		- Simplicity
			- As easy to understand as possible
			- Coherent/Consistent
			- Fewer moving parts
		- Restriction
			- Access on an as needed basis
				- e.g., divide superuser into several managerial roles with different access privileges instead of combining into a single role
			- Don't allow communication between components that don't require any communication
			
Robust Programming

	- Paranoia: any input not generated by your code is a suspect and must be subjected to scrutiny
	- Stupidity: any user could possibly misuse the program
	- Dangerous Implements: do not write code that is dependent on the internal implementation of an external dependency
		- e.g., directly accessing items by index from an internal array, as it might change to another data structure at a later date
		- If something must remain constant across calls, make sure no external source can modify it (immutable, private with no accessors, etc.)
	- Assumption of Impossibility: belief that some condition is impossible and thus not writing error handling for that eventuality
	
Programming
	- Cohesion
		- If all parts of the function work towards the same goal, the cohesion is high
		- If the function tries to accomplish 2+ goals, then cohesion is low
			- The function should be split into as many functions as there are goals
	- Checklist:
		- Make interfaces as simple as possible
		- Check/validate all parameters (even internally generated ones)
		- Check/validate all assumptions (pre-conditions & post-conditions)
		- Give useful error messages
		- Check for failure of library method calls
		- Decompose complex tasks into atomic functions
		- Place all security-relevant code into a single module instead of interweaving/interspersing
		
Formal, Informal, Ad Hoc Methods
	- Formal Methods: Using math to prove your code is correct	[Most Robust]
		- Specification, Design, Implementation
			- Specify goals, prove design reaches goals, prove implementation = design; thus, goals are reached by implementation
		- Specifications can include:
			- Pre-conditions, process, & post-conditions
				- Pre-conditions are assumptions of state and input prior to execution of function
				- Post-conditions are the results given a certain input
	- Informal Methods: Using arguments to suggest correctness	[Middle]
		- Imitate Formal methods:
			- Specify the goals clearly and completely
				- Pre-conditions & post-conditions
			- Understand the environment where the program will run
			- Know your assumptions
	- Ad Hoc: Using tests to suggest correctness				[Most Fragile]
	
STRIDE
	- Spoofing					[Confidentiality, Integrity]
	- Tampering 				[Integrity]
	- Repudiation				[Integrity]
	- Info Leak					[Confidentiality]
	- DoS						[Availability]
	- Elevation of Privilege	[C, I, A]
	
OpSec
	- Identify critical assets (physical/intellectual)
	- Identify threats
	- Identify vulnerabilities
	- Identify risks (if a threat and vulnerability match, there is a risk)
	- Implement countermeasures
	- Determine efficacy of countermeasures
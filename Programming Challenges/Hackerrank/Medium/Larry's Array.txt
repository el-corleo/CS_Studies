https://www.hackerrank.com/challenges/larrys-array/problem

Inputs:
	- n = arr length
	- A = arr elements
	
Output:
	- YES if A can be sorted
	- NO if A cannot be sorted
	
Constraints:
	- 3 <= n <= 1000
	- 1 <= A[i] <= n
	- sorted means integers increment by 1 from 1 to n
	- must use some combination of rotations where ABC -> BCA -> CAB -> ABC
	
Samples:
	-	A				rotate		Output
		[1,6,5,2,4,3]	[6,5,2]		YES
		[1,5,2,6,4,3]	[5,2,6]
		[1,2,6,5,4,3]	[5,4,3]
		[1,2,6,4,3,5]	[6,4,3]
		[1,2,4,3,6,5]	[4,3,6]
		[1,2,3,6,4,5]	[6,4,5]
		[1,2,3,4,5,6]
		
	-	A				rotate		Output
		[1,6,5,2,3,4]	[6,5,2]		NO		[6,5,4], [5,4,6], [4,6,5]
		[1,5,2,6,3,4]	[5,2,6]
		[1,2,6,5,3,4]	[6,5,3]
		[1,2,5,3,6,4]	[5,3,6]
		[1,2,3,6,5,4]
		
		
	- 	A				rotate		Output
		[1,2,3,5,4]					NO		[3,5,4], [5,4,3], [4,3,5]

	-	A
		[1,3,5,4,2]		[5,4,2]
		[1,3,4,2,5]		[4,2,5]
		[1,3,2,5,4]		[3,2,5]
		[1,2,5,3,4]		[5,3,4]
		[1,2,3,4,5]
		

Observations:
	- Can sort by putting each element in place one by one
	- [EDGE CASE] Can check for sequentiality by summing the numbers
	- This is like a weird bubble sort
	
Approach:
	- Find first out of order element, rotate elements until it's in place
		- If you get to the final triplet, and they cannot be rotated to satisfy this criteria, return "NO"
	- If fully sorted, then return "YES"
	
Code:
...

	private static void rotate(List<Integer> A, int nRotations, int startInd) {
        while (nRotations > 0) {
            int tmp = A.get(startInd+1);
            // change last -> second
            A.set(startInd+1, A.get(startInd+2));
            // change first -> last
            A.set(startInd+2, A.get(startInd));
            // change second -> first
            A.set(startInd, tmp);
            
            // decrement rotations to do
            nRotations--;
        }    
    }
    
    private static boolean sortElementAt(List<Integer> A, int ind) {
        // find location of element
        int elemInd = ind + 1;
        while (A.get(elemInd) != ind + 1)
            if (++elemInd == A.size()) return false;
        
        // rotate elem into proper position
        if (elemInd == ind + 1) rotate(A, 1, ind);
        else                    rotate(A, 2, elemInd-2);
        
        if (A.get(ind) != ind+1) sortElementAt(A, ind);
        
        return true;
    }

    public static String larrysArray(List<Integer> A) {
        // Edge case (non-sequential)
        int sum = (A.size() * (A.size()+1)) / 2;
        for (Integer i : A) sum -= i;
        if (sum != 0) return "NO";
        
        // Sort by finding first unordered element
        for (int i = 0; i < A.size() - 2; i++) {
            // if element is not in its proper spot
            if (A.get(i) != i+1)	sortElementAt(A, i);
        }
        
        // After the sort, the penultimate element should be ordered
        if (A.get(A.size()-2) != A.size()-1) return "NO";
        
        return "YES";
    }
	
...